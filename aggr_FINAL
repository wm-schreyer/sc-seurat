R version 4.0.2 (2020-06-22)
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

install.packages('Seurat')
library(Seurat)
library(ggplot2)
library(viridis)

# create object for Infected population count matrix
pos.data <- Read10X(data.dir = "pos_tsv")
pos.object <- CreateSeuratObject(counts = pos.data, project = "Pos")
pos.object

# create object for Bystander population count matrix
neg.data <- Read10X(data.dir = "neg_tsv")
neg.object <- CreateSeuratObject(counts = neg.data, project = "Neg")
neg.object

# create object for Control population count matrix
uni.data <- Read10X(data.dir = "uni_tsv")
uni.object <- CreateSeuratObject(counts = uni.data, project = "Ctrl")
uni.object

# merge objects for aggregate analysis
aggr.object <- merge(uni.object, y = c(pos.object, neg.object), add.cell.ids = c("Ctrl", "Pos", "Neg"), project = "aggr")
aggr.object

# calculate percentage of total transcripts from mt-genes
aggr.object[["percent.mt"]] <- PercentageFeatureSet(aggr.object, pattern = "^MT-")

# calculate percentage of total transcripts from rp-genes
aggr.object[["percent.rp"]] <- PercentageFeatureSet(aggr.object, pattern = "^RP")

# visualize aggr.object QC metrics as a violin plot
VlnPlot(aggr.object, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.rp"), ncol = 4, pt.size = 0.5)

# Filter out low quality reads **SCT Assay** - nGene filter sets min for unique features and UMI counts
aggr.filt <- subset(x = aggr.object, 
                    subset = (nFeature_RNA >= 200) &
                      (nFeature_RNA <= 8000) & 
                      (nCount_RNA >= 1000) &
                      (percent.mt < 50))

# check population cell numbers
table(aggr.filt$orig.ident)

# visualize aggr.filt QC metrics as a violin plot
VlnPlot(aggr.filt, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.rp"), ncol = 4, pt.size = 0.5)

# Extract counts
counts.aggr <- GetAssayData(object = aggr.filt, slot = "counts")

# Output a logical vector for every gene on whether the more than zero counts per cell
nonzero.aggr <- counts.aggr > 0

# Sums all TRUE values and returns TRUE if more than 1 TRUE values per gene
keep_genes.aggr <- Matrix::rowSums(nonzero.aggr) >= 1

# Only keeping those genes expressed in more than 1 cell
filtered_counts.aggr <- counts.aggr[keep_genes.aggr, ]

# Reassign to filtered Seurat object
aggr.filt <- CreateSeuratObject(filtered_counts.aggr, meta.data = aggr.filt@meta.data)

# run sctransform for Clustering, use default variable features limit (3,000), regress out percent.mt, nGene **SCT Assay**
aggr.filt <- SCTransform(aggr.filt, vars.to.regress = c("percent.mt","nFeature_RNA"), verbose = FALSE)

# run PCA and plot
aggr.filt <- RunPCA(aggr.filt, verbose = FALSE, assay = "SCT")
DimPlot(aggr.filt, reduction = 'pca')

# cluster cells
aggr.filt <- FindNeighbors(aggr.filt, dims = 1:40, verbose = FALSE, assay = "SCT")
aggr.filt <- FindClusters(aggr.filt, verbose = FALSE)

# run umap with 40 dims and plot
aggr.filt <- RunUMAP(aggr.filt, dims = 1:40, verbose = FALSE, assay = "SCT")

# plot umap by clusters
DimPlot(object = aggr.filt, reduction = 'umap')
# plot umap by pops
Idents(object = aggr.filt) <- "orig.ident"
DimPlot(object = aggr.filt, reduction = 'umap')

# normalize counts for DGE analysis **RNA Assay**
aggr.filt <- NormalizeData(aggr.filt, normalization.method = "LogNormalize", scale.factor = 10000, assay = "RNA")

# scale data
aggr.all.genes <- rownames(aggr.filt)
aggr.filt <- ScaleData(aggr.filt, features = aggr.all.genes, assay = "RNA")

# create grouping of genes of interest
madhur.genes <- c("AKT1", "BAD", "ATP6V1A", "BCL2", "HK2", "SLC7A11", "CXCL10", "CXCL8", "TNF", "CCL4", "CXCL1", "IL6", "CCL2", "CXCL12", "CSF2", "IL18", "CCL3", "IL1B", "CCL5", "IL2", "IL4", "IL5", "IL12A", "IL13", "IFNG", "IL10", "IL17", "CD80", "CD86", "CIITA", "HLA-DMB", "HLA-DQA1", "PKM", "STAT1", "HIF1A", "JUN", "MRC1", "CD36", "IL1RN", "CD163", "SOCS1", "NFKB1", "TLR8", "GLUL", "VEGFA", "MSR1", "IDO1", "IRF3", "ACTR3", "ARG1", "ARL8", "BECN1", "C1QBP", "CALCOCO2", "CANX", "CASP3", "CHAF1A", "CLTC", "CTSB", "CTSD", "CTTN", "CYCS", "EEA1", "FLOT1", "FLOT2", "ITGAM", "ITGAV", "ITGB3", "KEAP1", "LAMP1", "LAMP2", "LAMP3", "LGALS3", "LGALS8", "MAP1LC3A", "MAPK1", "MAPK3", "MCL1", "MTOR", "NFE2L2", "OSBPL1A", "PARP1", "PIKFYVE", "PRKACA", "PTDSS1", "RAB1B", "RAB24", "RAB5", "RAB7", "RHOA", "SQSTM1", "STX8", "SYT7", "TGFB1", "TLR2", "TLR4", "VAMP3", "VAMP7", "VAMP8", "VASP", "VPS35", "VPS41", "VTI1A", "VTI1B", "WASH1", "FAM21C", "YWHAB")

# heatmap of madhur.genes, normalized counts, viridis color scheme
DoHeatmap(aggr.filt, features = madhur.genes, assay = "RNA", group.by = 'orig.ident', slot = "counts") + scale_fill_viridis()
# heatmap of madhur.genes, scale.data
DoHeatmap(aggr.filt, features = madhur.genes, assay = "RNA", group.by = 'orig.ident')

# determine dge for genes of interest based on population
FindMarkers(aggr.filt, ident.1 = "pos", features = madhur.genes, assay = "RNA")

# switch idents to population for dge
Idents(object = aggr.filt) <- "orig.ident"
# switch default assay for visualization vs. dge
DefaultAssay(aggr.filt) <- "insert assay here"

# run dge analysis for aggr.filt between populations for Pos
aggr.dge.pos <- FindMarkers(object = aggr.filt, ident.1 = "Pos", ident.2 = NULL, assay = "RNA", test.use = "DESeq2")

# create csv file and export
write.csv(aggr.dge.pos, file = "aggr.dge.pos.csv")

# run dge analysis for aggr.filt between populations for Neg
aggr.dge.neg <- FindMarkers(object = aggr.filt, ident.1 = "Neg", ident.2 = NULL, assay = "RNA", test.use = "DESeq2")

# create csv file and export
write.csv(aggr.dge.neg, file = "aggr.dge.neg.csv")

# run dge analysis for aggr.filt between populations for Ctrl
aggr.dge.ctrl <- FindMarkers(object = aggr.filt, ident.1 = "Ctrl", ident.2 = NULL, assay = "RNA", test.use = "DESeq2")

# create csv file and export
write.csv(aggr.dge.ctrl, file = "aggr.dge.ctrl.csv")
